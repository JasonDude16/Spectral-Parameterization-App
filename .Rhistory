for (j in 1:nrow(CF)) {
if (is.na(CF[j, i])) {
next
}
if (CF[j, i] > 8 && CF[j, i] < 12) {
CF[j, CF_col] <- CF[j, i]
PW[j, PW_col] <- PW[j, i]
BW[j, PW_col] <- BW[j, i]
}
}
if (sum(is.na(CF[CF_col])) == 0) {
break
}
}
df <- merge(CF, PW)
df <- merge(df, BW)
return(df)
})
# make an object for IDs, then remove IDs from data so datasets can be merged without conflicts
IDs <- dat_final[[1]]$ID
dat_final <- map(dat_final, ~ select(.x, -ID))
dat_final <- map_dfc(dat_final, ~ .x)
dat_final$ID <- IDs
dat_final <- dat_final[c(length(dat_final), (2:length(dat_final) - 1))]
# change IDs from XXXXX_X to XXXXX, and append condition and # of channels to columns
dat_final$ID <- sub("_[0-9]", "", dat_final$ID)
colnames(dat_final)[-1] <- paste0(colnames(dat_final)[-1], "_", condition, "_", n_channels)
names(dat_fooof) <- dat_final$ID
alpha_NA <- map(channels_interested, function(x){
df <- select(dat_final, ID, contains(paste0("alpha", "_", x)))
IDs <- which(is.na(df[2]))
df[IDs, 1]
})
names(alpha_NA) <- channels_interested
alpha_NA
View(dat_fooof)
saveRDS(dat_fooof, "rbl_adol_EC_64.RDS")
saveRDS(alpha_NA, "no_alpha_EC_64.RDS")
library(dplyr)
library(purrr)
library(textshape)
library(reticulate)
np <- import("numpy")
plt <- import("matplotlib.pyplot")
fooof <- import("fooof")
# file name, condition, # of channels, and channels analyzing
file <- "RBL_1f_EO_32.xlsx"
condition <- "EO"
n_channels <- "32"
channels_interested <- c("F3", "F4", "F7", "F8", "P3", "P4", "P7", "P8")
# get the number of excel sheets and remove empty sheets
n_sheets <- readxl::excel_sheets(file)
sheets_skip <- stringr::str_which(n_sheets, "Sheet")
# read in sheets and make the ID number the list item name
dat <- map(n_sheets[-sheets_skip], ~ readxl::read_excel(path = file, sheet = .x))
names(dat) <- n_sheets[-sheets_skip]
# select only channels interested in analyzing
dat_select_channels <- map(dat, ~ filter(.x, channels %in% channels_interested))
# turn into matrix where rownames are channels
dat_mat <- map(dat_select_channels, ~ column_to_rownames(as.data.frame(.x), loc = "channels"))
# then transpose matrix so channels are columns and frequencies are rownames
dat_t <- map(dat_mat, t)
# use regular expression to change rownames from x...x to x
names <- map(dat_t, ~ gsub(pattern = "\\.\\.\\.(.*)", replacement = "", rownames(.x)))
dat_t <- map2(dat_t, names, function(.x, .y) {row.names(.x) <- .y; return(.x)})
# determine what the frequencies are for each subject (should all be the same)
(freqs <- map(dat_t, ~ names(summary(as.factor(as.numeric(row.names(.x)))))))
# determine how many time points there are for each frequency (# obs)
(freq_count <- map(dat_t, ~ summary(as.factor(as.numeric(row.names(.x))))))
# calculate the mean for each frequency
dat_sum <- map(dat_t, ~ rowsum(.x, group = as.numeric(row.names(.x))))
dat_avg_freq <- map(dat_sum, ~ .x[NA, ])
dat_list <- list(dat_avg_freq, dat_sum, freqs, freq_count)
dat_avg_freq <- pmap(dat_list, function(.w, .x, .y, .z) {
for (i in 1:nrow(.w)) {
.w[i, ] <- subset(.x, rownames(.x) %in% .y[[i]]) / .z[[i]]
}
return(.w)
})
dat_avg_freq <- map2(dat_avg_freq, freqs, function(.x, .y) {row.names(.x) <- .y; return(.x)})
# formatting for FOOOF
dat_fooof <- map(.x = names(dat_avg_freq), function(.x) {
dat_avg_freq[[.x]] <- list("spectrum" = dat_avg_freq[[.x]],
"freqs" = as.matrix(as.numeric(row.names(dat_avg_freq[[.x]]))))
})
names(dat_fooof) <- names(dat_avg_freq)
# FOOOF algorithm
fooof_model_data <- NULL
fm <- fooof$FOOOF(peak_width_limits = c(2.5, 8), max_n_peaks = 6, min_peak_height = .1, peak_threshold = 2)
for (i in 1:length(dat_fooof)) {
for (j in 1:ncol(dat_fooof[[i]]$spectrum)) {
fm$fit(freqs = np$ravel(dat_fooof[[i]]$freqs), power_spectrum = np$ravel(dat_fooof[[i]]$spectrum[ ,j]))
if (purrr::is_empty(fm$peak_params_)) {
peak_params <- data.frame(CF = NA, PW = NA, BW = NA)
} else {
peak_params <- data.frame(CF = fm$peak_params_[ ,1],
PW = fm$peak_params_[ ,2],
BW = fm$peak_params_[ ,3],
index = 1:nrow(fm$peak_params_))
peak_params <- tidyr::pivot_wider(peak_params, values_from = c("CF", "PW", "BW"), names_from = "index")
}
electrode <- colnames(dat_fooof[[i]]$spectrum)[j]
df <- data.frame(ID = names(dat_fooof)[i],
electrode = electrode,
offset = fm$aperiodic_params_[1],
exponent = fm$aperiodic_params_[2],
r_squared = fm$r_squared_,
error = fm$error_,
peak_params)
fooof_model_data[[names(dat_fooof)[i]]][["data"]][[electrode]] <- df
}
fooof_model_data[[names(dat_fooof)[i]]][["settings"]] <- fm$get_settings()
}
# reformatting data in wide and 'semi-wide' formats
dat_semi_wide <- map(names(fooof_model_data), ~ map_dfr(fooof_model_data[[.x]]$data, ~ .x))
dat_semi_wide_comb <- map_dfr(dat_semi_wide, ~ .x)
wide <- map(dat_semi_wide, function(.x){
df <- .x[c(2, 7:ncol(.x))]
df <- tidyr::pivot_wider(df, names_from = "electrode", values_from = 2:ncol(df))
df <- cbind(.x[1, c(1, 3:6)], df)
})
wide <- map_dfr(wide, ~ .x)
# creating variable of alpha (first CF peak between 8 and 12), and the alpha power and bandwidth
dat_final <- map(channels_interested, function(.x, data = wide) {
CF <- dplyr::select(data, ID, ends_with(.x) & starts_with("CF"))
PW <- dplyr::select(data, ID, ends_with(.x) & starts_with("PW"))
BW <- dplyr::select(data, ID, ends_with(.x) & starts_with("BW"))
CF[paste0("CF_alpha_", .x)] <- NA
PW[paste0("PW_alpha_", .x)] <- NA
BW[paste0("BW_alpha_", .x)] <- NA
CF_col <- which(colnames(CF) == paste0("CF_alpha_", .x))
PW_col <- which(colnames(PW) == paste0("PW_alpha_", .x))
BW_col <- which(colnames(BW) == paste0("BW_alpha_", .x))
for (i in 1:ncol(CF)) {
for (j in 1:nrow(CF)) {
if (is.na(CF[j, i])) {
next
}
if (CF[j, i] > 8 && CF[j, i] < 12) {
CF[j, CF_col] <- CF[j, i]
PW[j, PW_col] <- PW[j, i]
BW[j, PW_col] <- BW[j, i]
}
}
if (sum(is.na(CF[CF_col])) == 0) {
break
}
}
df <- merge(CF, PW)
df <- merge(df, BW)
return(df)
})
# make an object for IDs, then remove IDs from data so datasets can be merged without conflicts
IDs <- dat_final[[1]]$ID
dat_final <- map(dat_final, ~ select(.x, -ID))
dat_final <- map_dfc(dat_final, ~ .x)
dat_final$ID <- IDs
dat_final <- dat_final[c(length(dat_final), (2:length(dat_final) - 1))]
# change IDs from XXXXX_X to XXXXX, and append condition and # of channels to columns
dat_final$ID <- sub("_[0-9]", "", dat_final$ID)
colnames(dat_final)[-1] <- paste0(colnames(dat_final)[-1], "_", condition, "_", n_channels)
names(dat_fooof) <- dat_final$ID
alpha_NA <- map(channels_interested, function(x){
df <- select(dat_final, ID, contains(paste0("alpha", "_", x)))
IDs <- which(is.na(df[2]))
df[IDs, 1]
})
names(alpha_NA) <- channels_interested
saveRDS(dat_fooof, "rbl_adol_EO_32.RDS")
saveRDS(alpha_NA, "no_alpha_EO_32.RDS")
library(dplyr)
library(purrr)
library(textshape)
library(reticulate)
np <- import("numpy")
plt <- import("matplotlib.pyplot")
fooof <- import("fooof")
# file name, condition, # of channels, and channels analyzing
file <- "RBL_1f_EO_64.xlsx"
condition <- "EO"
n_channels <- "64"
channels_interested <- c("F3", "F4", "F7", "F8", "P3", "P4", "P7", "P8")
# get the number of excel sheets and remove empty sheets
n_sheets <- readxl::excel_sheets(file)
sheets_skip <- stringr::str_which(n_sheets, "Sheet")
# read in sheets and make the ID number the list item name
dat <- map(n_sheets[-sheets_skip], ~ readxl::read_excel(path = file, sheet = .x))
names(dat) <- n_sheets[-sheets_skip]
# select only channels interested in analyzing
dat_select_channels <- map(dat, ~ filter(.x, channels %in% channels_interested))
# turn into matrix where rownames are channels
dat_mat <- map(dat_select_channels, ~ column_to_rownames(as.data.frame(.x), loc = "channels"))
# then transpose matrix so channels are columns and frequencies are rownames
dat_t <- map(dat_mat, t)
# use regular expression to change rownames from x...x to x
names <- map(dat_t, ~ gsub(pattern = "\\.\\.\\.(.*)", replacement = "", rownames(.x)))
dat_t <- map2(dat_t, names, function(.x, .y) {row.names(.x) <- .y; return(.x)})
# determine what the frequencies are for each subject (should all be the same)
(freqs <- map(dat_t, ~ names(summary(as.factor(as.numeric(row.names(.x)))))))
# determine how many time points there are for each frequency (# obs)
(freq_count <- map(dat_t, ~ summary(as.factor(as.numeric(row.names(.x))))))
# calculate the mean for each frequency
dat_sum <- map(dat_t, ~ rowsum(.x, group = as.numeric(row.names(.x))))
dat_avg_freq <- map(dat_sum, ~ .x[NA, ])
dat_list <- list(dat_avg_freq, dat_sum, freqs, freq_count)
dat_avg_freq <- pmap(dat_list, function(.w, .x, .y, .z) {
for (i in 1:nrow(.w)) {
.w[i, ] <- subset(.x, rownames(.x) %in% .y[[i]]) / .z[[i]]
}
return(.w)
})
dat_avg_freq <- map2(dat_avg_freq, freqs, function(.x, .y) {row.names(.x) <- .y; return(.x)})
# formatting for FOOOF
dat_fooof <- map(.x = names(dat_avg_freq), function(.x) {
dat_avg_freq[[.x]] <- list("spectrum" = dat_avg_freq[[.x]],
"freqs" = as.matrix(as.numeric(row.names(dat_avg_freq[[.x]]))))
})
names(dat_fooof) <- names(dat_avg_freq)
# FOOOF algorithm
fooof_model_data <- NULL
fm <- fooof$FOOOF(peak_width_limits = c(2.5, 8), max_n_peaks = 6, min_peak_height = .1, peak_threshold = 2)
for (i in 1:length(dat_fooof)) {
for (j in 1:ncol(dat_fooof[[i]]$spectrum)) {
fm$fit(freqs = np$ravel(dat_fooof[[i]]$freqs), power_spectrum = np$ravel(dat_fooof[[i]]$spectrum[ ,j]))
if (purrr::is_empty(fm$peak_params_)) {
peak_params <- data.frame(CF = NA, PW = NA, BW = NA)
} else {
peak_params <- data.frame(CF = fm$peak_params_[ ,1],
PW = fm$peak_params_[ ,2],
BW = fm$peak_params_[ ,3],
index = 1:nrow(fm$peak_params_))
peak_params <- tidyr::pivot_wider(peak_params, values_from = c("CF", "PW", "BW"), names_from = "index")
}
electrode <- colnames(dat_fooof[[i]]$spectrum)[j]
df <- data.frame(ID = names(dat_fooof)[i],
electrode = electrode,
offset = fm$aperiodic_params_[1],
exponent = fm$aperiodic_params_[2],
r_squared = fm$r_squared_,
error = fm$error_,
peak_params)
fooof_model_data[[names(dat_fooof)[i]]][["data"]][[electrode]] <- df
}
fooof_model_data[[names(dat_fooof)[i]]][["settings"]] <- fm$get_settings()
}
# reformatting data in wide and 'semi-wide' formats
dat_semi_wide <- map(names(fooof_model_data), ~ map_dfr(fooof_model_data[[.x]]$data, ~ .x))
dat_semi_wide_comb <- map_dfr(dat_semi_wide, ~ .x)
wide <- map(dat_semi_wide, function(.x){
df <- .x[c(2, 7:ncol(.x))]
df <- tidyr::pivot_wider(df, names_from = "electrode", values_from = 2:ncol(df))
df <- cbind(.x[1, c(1, 3:6)], df)
})
wide <- map_dfr(wide, ~ .x)
# creating variable of alpha (first CF peak between 8 and 12), and the alpha power and bandwidth
dat_final <- map(channels_interested, function(.x, data = wide) {
CF <- dplyr::select(data, ID, ends_with(.x) & starts_with("CF"))
PW <- dplyr::select(data, ID, ends_with(.x) & starts_with("PW"))
BW <- dplyr::select(data, ID, ends_with(.x) & starts_with("BW"))
CF[paste0("CF_alpha_", .x)] <- NA
PW[paste0("PW_alpha_", .x)] <- NA
BW[paste0("BW_alpha_", .x)] <- NA
CF_col <- which(colnames(CF) == paste0("CF_alpha_", .x))
PW_col <- which(colnames(PW) == paste0("PW_alpha_", .x))
BW_col <- which(colnames(BW) == paste0("BW_alpha_", .x))
for (i in 1:ncol(CF)) {
for (j in 1:nrow(CF)) {
if (is.na(CF[j, i])) {
next
}
if (CF[j, i] > 8 && CF[j, i] < 12) {
CF[j, CF_col] <- CF[j, i]
PW[j, PW_col] <- PW[j, i]
BW[j, PW_col] <- BW[j, i]
}
}
if (sum(is.na(CF[CF_col])) == 0) {
break
}
}
df <- merge(CF, PW)
df <- merge(df, BW)
return(df)
})
# make an object for IDs, then remove IDs from data so datasets can be merged without conflicts
IDs <- dat_final[[1]]$ID
dat_final <- map(dat_final, ~ select(.x, -ID))
dat_final <- map_dfc(dat_final, ~ .x)
dat_final$ID <- IDs
dat_final <- dat_final[c(length(dat_final), (2:length(dat_final) - 1))]
# change IDs from XXXXX_X to XXXXX, and append condition and # of channels to columns
dat_final$ID <- sub("_[0-9]", "", dat_final$ID)
colnames(dat_final)[-1] <- paste0(colnames(dat_final)[-1], "_", condition, "_", n_channels)
names(dat_fooof) <- dat_final$ID
alpha_NA <- map(channels_interested, function(x){
df <- select(dat_final, ID, contains(paste0("alpha", "_", x)))
IDs <- which(is.na(df[2]))
df[IDs, 1]
})
names(alpha_NA) <- channels_interested
saveRDS(dat_fooof, "rbl_adol_EO_64.RDS")
saveRDS(alpha_NA, "no_alpha_EO_64.RDS")
shiny::runApp('/Volumes/psych_icanlab/Staff/DATA Management/Version Control/NEMO_Purdue/Shiny_Apps/Spectral_Parameterization')
setwd("/Volumes/psych_icanlab/Staff/DATA Management/Version Control/NEMO_Purdue/Shiny_Apps/Spectral_Parameterization"
)
getwd()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp('~/Desktop/Spectral_Parameterization')
shiny::runApp()
no_alpha_fooof_settings <- readRDS("./data/no_alpha_fooof_settings.RDS")
View(no_alpha_fooof_settings)
View(no_alpha_fooof_settings)
readRDS("./data/no_alpha_fooof_settings.RDS")
library(reticulate)
fooof <- import("fooof")
fm <- fooof$FOOOF()
fm <- fooof$FOOOF(fooof$FOOOF(peak_width_limits = c(2.5, 8), max_n_peaks = 6, min_peak_height = .1, peak_threshold = 2))
fooof <- import("fooof")
fm <- fooof$FOOOF(fooof$FOOOF(peak_width_limits = c(2.5, 8), max_n_peaks = 6, min_peak_height = .1, peak_threshold = 2))
fm <- fooof$FOOOF(peak_width_limits = c(2.5, 8), max_n_peaks = 6, min_peak_height = .1, peak_threshold = 2)
fm$get_settings()
list(fm$get_settings())
c(fm$get_settings())
test <- (fm$get_settings())
test
is.vector(test)
class(test)
test <- c(fm$get_settings())
class(test)
test
setwd("Z:/Staff/DATA Management/Version Control/NEMO_Purdue/Shiny_Apps/Spectral_Parameterization/data")
saveRDS(test, "no_alpha_fooof_settings.RDS")
setwd("Z:/Staff/DATA Management/Version Control/NEMO_Purdue/Shiny_Apps/Spectral_Parameterization")
readRDS("./data/no_alpha_fooof_settings.RDS")
t <- readRDS("./data/no_alpha_fooof_settings.RDS")
t
test
list(fm$get_settings())
test <- list(fm$get_settings())
saveRDS(test, "no_alpha_fooof_settings.RDS")
readRDS("no_alpha_fooof_settings.RDS")
test <- list(fm$get_settings())
test
View(test)
test[[1]]
test <- as.list(fm$get_settings())
fm$get_settings()
test <- list(fm$get_settings())
test <- as.list(list(fm$get_settings()))
test
View(test)
test <- as.vector(fm$get_settings())
fm$get_settings()
saveRDS(c("FOOOFSettings(peak_width_limits=[2.5, 8.0], max_n_peaks=6.0, min_peak_height=0.1, peak_threshold=2.0, aperiodic_mode='fixed')"), "no_alpha_fooof_settings.RDS")
t <- readRDS("./data/no_alpha_fooof_settings.RDS")
t
no_alpha_fooof_settings <- readRDS("Z:/Staff/DATA Management/Version Control/NEMO_Purdue/Shiny_Apps/Spectral_Parameterization/no_alpha_fooof_settings.RDS")
no_alpha_fooof_settings <- readRDS("Z:/Staff/DATA Management/Version Control/NEMO_Purdue/Shiny_Apps/Spectral_Parameterization/no_alpha_fooof_settings.RDS")
t <- readRDS("./no_alpha_fooof_settings.RDS")
test <- list(fm$get_settings())
saveRDS(test, "no_alpha_fooof_settings.RDS")
t2 <- readRDS("./no_alpha_fooof_settings.RDS")
View(t2)
t2
saveRDS(c("FOOOFSettings(peak_width_limits=[2.5, 8.0], max_n_peaks=6.0, min_peak_height=0.1, peak_threshold=2.0, aperiodic_mode='fixed')"), "no_alpha_fooof_settings.RDS")
t2 <- readRDS("./no_alpha_fooof_settings.RDS")
t2
no_alpha_fooof_settings <- readRDS("./no_alpha_fooof_settings.RDS")
runApp()
no_alpha_fooof_settings
runApp()
shiny::runApp()
shiny::runApp()
devtools::install_github("hadley/requirements")
requirements::req_file()
requirements::req_file("test")
requirements::req_file("./test")
requirements::req_file("ui.R")
requirements::req_file(path = "./")
requirements::req_file(path = "server.R")
requirements::req_code(path = "server.R")
requirements::req_code()
requirements::req_file("ui.R")
requirements::req_file("server.R")
requirements::req_file("ui.R")
requirements::req_file("server.R")
setwd("~/Documents/projects/Spectral_Parameterization/R")
map(list.files, requirements::req_file)
purrr::map(list.files, requirements::req_file)
list.files
purrr::map(list.files(), requirements::req_file)
purrr::map(list.files(), requirements::req_file))
unique(list(
requirements::req_file("ui.R"),
requirements::req_file("server.R"),
purrr::map(list.files(), requirements::req_file)))
unique(list(
requirements::req_file("../ui.R"),
requirements::req_file("../server.R"),
purrr::map(list.files(), requirements::req_file)))
require("tidyr")
require("tea")
require("packrat")
setwd("~/Documents/projects/Spectral_Parameterization")
packrat::init()
reticulate::virtualenv_create("spec_param", packages = c("numpy", "fooof", "matplotlib", ""))
reticulate::virtualenv_list()
install.packages("renv")
library(renv)
use_python()
runApp()
shiny::runApp()
runApp()
runApp()
install.packages("crosstalk")
runApp()
install.packages("reticulate")
shiny::runApp()
install.packages("DT")
runApp()
install.packages("DT")
shiny::runApp()
runApp()
runApp()
runApp()
histogramUI <- function(id) {
tagList(
selectInput(NS(id, "var"), "Variable", choices = names(mtcars)),
numericInput(NS(id, "bins"), "bins", value = 10, min = 1),
plotOutput(NS(id, "hist"))
)
}
histogramServer <- function(id) {
moduleServer(id, function(input, output, session) {
data <- reactive(mtcars[[input$var]])
output$hist <- renderPlot({
hist(data(), breaks = input$bins, main = input$var)
}, res = 96)
})
}
histogramApp <- function() {
ui <- fluidPage(
histogramUI("hist1")
)
server <- function(input, output, session) {
histogramServer("hist1")
}
shinyApp(ui, server)
}
histogramApp()
histogramApp()
force(add_count_)
force(summarize_at)
View(slice_)
View(setdiff)
View(transmute)
View(transmute_at)
View(ungroup)
force(mutate_all)
renv::init()
renv::snapshot()
shiny::runApp()
install.packages("png")
runApp()
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
checkboxInput("somevalue", "Some value", FALSE),
verbatimTextOutput("value")
)
server <- function(input, output) {
output$value <- renderText({ input$somevalue })
}
shinyApp(ui, server)
}
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
checkboxGroupInput("variable", "Variables to show:",
c("Cylinders" = "cyl",
"Transmission" = "am",
"Gears" = "gear")),
tableOutput("data")
)
server <- function(input, output, session) {
output$data <- renderTable({
mtcars[, c("mpg", input$variable), drop = FALSE]
}, rownames = TRUE)
}
shinyApp(ui, server)
ui <- fluidPage(
checkboxGroupInput("icons", "Choose icons:",
choiceNames =
list(icon("calendar"), icon("bed"),
icon("cog"), icon("bug")),
choiceValues =
list("calendar", "bed", "cog", "bug")
),
textOutput("txt")
)
server <- function(input, output, session) {
output$txt <- renderText({
icons <- paste(input$icons, collapse = ", ")
paste("You chose", icons)
})
}
shinyApp(ui, server)
}
